---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-10-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary

This month’s deep dive focused on **graph algorithms**, covering a diverse set of challenging problems ranging from **shortest paths** to **network connectivity** and **minimum spanning trees**. The selected problems span multiple algorithmic paradigms including **Bellman–Ford relaxations**, **Tarjan’s bridge-finding**, **Kruskal’s MST**, and **Floyd–Warshall all-pairs shortest paths**.

These problems not only deepen understanding of graph theory fundamentals but also illustrate practical applications in real-world domains such as network optimization, urban planning, and fault tolerance in distributed systems.

### Key Learnings and Skills Developed

- **Single-source shortest paths** (LeetCode 743): Implemented Dijkstra’s algorithm using a priority queue to efficiently compute propagation times in weighted directed graphs, with a focus on signal transmission delays across a network.
- **Limited relaxation shortest paths** (LeetCode 787): Learned how to handle pathfinding under hop constraints using Bellman–Ford principles and BFS with state tracking.
- **Graph articulation analysis** (LeetCode 1192): Mastered Tarjan’s algorithm for bridge detection, deepening knowledge of DFS timestamps and low-link values for connectivity analysis.
- **Minimum spanning trees** (LeetCode 1584): Practiced Kruskal’s algorithm and union-find optimization, reinforcing concepts of cycle detection and component merging in weighted graphs.
- **Algorithmic trade-offs**: Evaluated complexity vs. scalability across multiple graph algorithms, noting strengths and weaknesses depending on graph structure and constraints.

### Practical Applications

The selected problems simulate scenarios faced in real-world engineering challenges:
- **Network routing optimization**: Finding cheapest routes under constraints, essential for transport and communication networks.
- **Infrastructure resilience**: Detecting critical connections to ensure fault tolerance in networks.
- **Efficient resource allocation**: Building minimum-cost infrastructure connecting all points (e.g., pipelines, electric grids).
- **Urban planning**: Identifying the most connected or isolated nodes for city design and logistics.
- **System performance analysis**: Evaluating different algorithms for all-pairs shortest paths in various network sizes and densities.

### Summary of Achievements

By solving these five problems, significant progress was made in mastering advanced graph algorithms and practical problem-solving strategies. This month’s work also strengthened skills in:
- Designing optimized algorithms under specific constraints.
- Applying graph traversal techniques in complex scenarios.
- Performing rigorous complexity analysis and trade-off evaluation.
- Translating theoretical concepts into clean, maintainable Java implementations.

This body of work forms a solid foundation for tackling even more complex graph-based challenges in the upcoming months.

## 1. LeetCode 743. Network Delay Time
**Topic:** Dijkstra’s Algorithm – Shortest Path in Weighted Graph

### Problem Summary
You are given a list of travel times as directed edges between nodes, and a signal starting from node `k`. Determine how long it takes for all nodes to receive the signal, or return `-1` if some nodes are unreachable.

This problem embodies a core use-case of **weighted shortest paths** in networks (e.g., message propagation, network latency analysis, delivery routing).

### Why It Matters
Efficiently computing minimum propagation delay is crucial in routing, communication, and even distributed consensus systems.  
Dijkstra’s algorithm ensures optimality on graphs with non-negative weights, leveraging greedy expansion with a priority queue.

### Approach Overview
We use a **min-heap (priority queue)** to always expand the node with the smallest known distance.  
Each time we relax an edge, if we find a shorter path — we push it to the queue.  
Time complexity: `O(E log V)`.

### Java Solution
```java
import java.util.*;

public class NetworkDelayTime {
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] edge : times)
            graph.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});

        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[k] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        pq.offer(new int[]{k, 0});

        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int node = cur[0], time = cur[1];
            if (time > dist[node]) continue;

            for (int[] nei : graph.getOrDefault(node, Collections.emptyList())) {
                int newTime = time + nei[1];
                if (newTime < dist[nei[0]]) {
                    dist[nei[0]] = newTime;
                    pq.offer(new int[]{nei[0], newTime});
                }
            }
        }

        int max = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, dist[i]);
        }
        return max;
    }
}
```
Concepts Covered:

- Dijkstra’s algorithm

- Greedy path relaxation

- PriorityQueue-based graph traversal

- Handling disconnected components

---

## 2. LeetCode 787. Cheapest Flights Within K Stops

**Topic:** Bellman–Ford / BFS with State

### **Problem Summary**
Find the cheapest price from `src` to `dst` with at most `K` stops given a list of flight connections.

This problem extends the classic shortest path formulation by introducing a **constraint on the number of stops** (or edges).  
Unlike standard Dijkstra’s algorithm — which minimizes distance regardless of depth — this problem focuses on **minimizing cost within a bounded number of hops**.

### **Why It Matters / Problems It Solves**
- Models **limited-hop routing** in airline and telecommunication networks.
- Demonstrates **state-constrained pathfinding** where distance isn’t the only optimization parameter.
- Reinforces the idea of **relaxations with bounded depth**, which is foundational for graph problems in dynamic environments.

### **Approach Overview**
Two common strategies exist:

1. **Bellman–Ford with limited iterations**
    - Perform `K + 1` relaxations (each representing one additional hop).
    - Each iteration updates the cost for all edges but only allows propagation through paths ≤ `K` hops.
    - Ensures correctness since all edges are relaxed exactly as many times as the number of stops allowed.

2. **BFS-style search with state tracking**
    - Maintain a queue of tuples `(node, stops, cost)`.
    - Traverse the graph in breadth-first order, skipping expansions when `stops > K`.
    - Prioritize cost updates dynamically (sometimes hybridized with a min-heap).

**Time complexity:** `O(K * E)`  
**Space complexity:** `O(N)`

### **Java Solution**
```java
import java.util.*;

public class CheapestFlightsWithinKStops {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;

        for (int i = 0; i <= K; i++) {
            int[] temp = Arrays.copyOf(cost, n);
            for (int[] f : flights) {
                int u = f[0], v = f[1], w = f[2];
                if (cost[u] != Integer.MAX_VALUE && cost[u] + w < temp[v]) {
                    temp[v] = cost[u] + w;
                }
            }
            cost = temp;
        }
        return cost[dst] == Integer.MAX_VALUE ? -1 : cost[dst];
    }

    public static void main(String[] args) {
        CheapestFlightsWithinKStops solver = new CheapestFlightsWithinKStops();
        int[][] flights = {
            {0, 1, 100},
            {1, 2, 100},
            {0, 2, 500}
        };
        System.out.println(solver.findCheapestPrice(3, flights, 0, 2, 1)); // Output: 200
    }
}
```
Concepts Covered:

- Bellman–Ford algorithm under bounded relaxations.

- Edge relaxation and propagation control across limited depth.

- Difference between shortest path and limited-hop shortest path.

- BFS-style approach with (node, stops, cost) as the traversal state.

- Real-world applications: airline pricing, constrained route planning, dynamic network routing.

---

## 3. LeetCode 1192. Critical Connections in a Network

**Topic:** Tarjan’s Algorithm – Bridges in Undirected Graph

### **Problem Summary**
Find all **critical connections** (edges whose removal increases the number of connected components) in an undirected network.  
These edges, also known as **bridges**, are crucial links in a graph whose removal disconnects the graph.

**Applications:**
- Network reliability and fault tolerance.
- Dependency and communication graphs.
- Detecting single points of failure in distributed systems.

### **Why It Matters / Problems It Solves**
Understanding bridge detection is key in system resilience engineering — identifying **edges that cannot fail without splitting the system**.  
In distributed networks (e.g., Kubernetes clusters, blockchain overlays), Tarjan’s algorithm helps identify links critical to maintaining connectivity and synchronization.

### **Approach Overview**
We use **Tarjan’s Algorithm**, which runs a **single DFS traversal** to compute two key values for each node:
- **Discovery time (`disc[u]`)** — the time when the node is first visited.
- **Low-link value (`low[u]`)** — the earliest discovered node reachable from the subtree rooted at `u`.

An edge `(u, v)` is a **bridge** if and only if `low[v] > disc[u]`.  
This means there’s no back edge from `v` or its descendants connecting to any ancestor of `u`.

**Algorithm outline:**
1. Initialize discovery and low arrays to `-1`.
2. DFS from an arbitrary node (graph may be connected).
3. For each unvisited neighbor `v` of `u`, recursively visit it.
4. After DFS returns, update `low[u] = min(low[u], low[v])`.
5. If `low[v] > disc[u]`, then `(u, v)` is a **critical edge**.

**Time complexity:** `O(V + E)`  
**Space complexity:** `O(V + E)`

### **Java Solution**
```java
import java.util.*;

public class CriticalConnections {
    private int time = 0;
    private List<List<Integer>> result;

    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        for (List<Integer> c : connections) {
            graph.get(c.get(0)).add(c.get(1));
            graph.get(c.get(1)).add(c.get(0));
        }

        int[] disc = new int[n], low = new int[n];
        Arrays.fill(disc, -1);
        result = new ArrayList<>();

        dfs(0, -1, graph, disc, low);
        return result;
    }

    private void dfs(int u, int parent, List<List<Integer>> g, int[] disc, int[] low) {
        disc[u] = low[u] = ++time;
        for (int v : g.get(u)) {
            if (v == parent) continue;
            if (disc[v] == -1) {
                dfs(v, u, g, disc, low);
                low[u] = Math.min(low[u], low[v]);
                if (low[v] > disc[u]) result.add(Arrays.asList(u, v));
            } else {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }

    public static void main(String[] args) {
        CriticalConnections solver = new CriticalConnections();
        List<List<Integer>> connections = Arrays.asList(
            Arrays.asList(0, 1),
            Arrays.asList(1, 2),
            Arrays.asList(2, 0),
            Arrays.asList(1, 3)
        );
        System.out.println(solver.criticalConnections(4, connections)); // Output: [[1, 3]]
    }
}
```
Concepts Covered:

- Tarjan’s algorithm for bridge detection in undirected graphs.

- Low-link computation using DFS timestamps.

- Understanding back edges and their effect on connectivity.

- Relationship between bridges and articulation points.

- Real-world use cases:

  - Network topology optimization.

  - Fault-tolerant distributed systems.

  - Identifying weak connections in graph-based dependency models.

---

## 4. LeetCode 1584. Min Cost to Connect All Points

**Topic:** Minimum Spanning Tree (MST) – Kruskal + Union-Find

### **Problem Summary**
Connect all given points such that the **total connection cost** (defined by Manhattan distance) is minimal.  
This is equivalent to constructing a **Minimum Spanning Tree (MST)** on a **complete weighted graph** with `O(n²)` edges.

**Use cases:**
- Network cabling layout (minimal wire length).
- Connecting cities with minimal road cost.
- Clustering and graph optimization problems.

### **Why It Matters / Problems It Solves**
Finding minimal connection cost between all nodes is a foundational problem in graph theory and real-world optimization:  
from **network routing** to **supply chain design**.

The MST ensures that all nodes are connected with the **least total cost**, without cycles, which translates to resource-efficient designs in various systems.

### **Approach Overview**
We apply **Kruskal’s algorithm** with a **Union-Find (Disjoint Set Union)** structure to efficiently detect cycles.  
Steps:
1. Compute all possible edges between points and their Manhattan distances.
2. Sort edges by cost in ascending order.
3. Iterate through sorted edges and connect components using Union-Find.
4. Stop when `n - 1` edges are included in the MST.

**Alternative:**  
Use **Prim’s algorithm** with a min-heap for better performance on sparse graphs (`O(n² log n)` → `O(n log n)` with optimized adjacency).

**Time complexity:** `O(n² log n)`  
**Space complexity:** `O(n²)` (due to complete graph edge list).

### **Java Solution**
```java
import java.util.*;

public class MinCostToConnectAllPoints {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int cost = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                edges.add(new int[]{i, j, cost});
            }
        }

        edges.sort(Comparator.comparingInt(a -> a[2]));
        UnionFind uf = new UnionFind(n);
        int total = 0, count = 0;

        for (int[] e : edges) {
            if (uf.union(e[0], e[1])) {
                total += e[2];
                if (++count == n - 1) break;
            }
        }
        return total;
    }

    static class UnionFind {
        int[] parent, rank;
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }

        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        boolean union(int x, int y) {
            int rx = find(x), ry = find(y);
            if (rx == ry) return false;
            if (rank[rx] < rank[ry]) parent[rx] = ry;
            else if (rank[rx] > rank[ry]) parent[ry] = rx;
            else {
                parent[ry] = rx;
                rank[rx]++;
            }
            return true;
        }
    }

    public static void main(String[] args) {
        MinCostToConnectAllPoints solver = new MinCostToConnectAllPoints();
        int[][] points = {{0,0},{2,2},{3,10},{5,2},{7,0}};
        System.out.println(solver.minCostConnectPoints(points)); // Output: 20
    }
}
```
Concepts Covered:

- Kruskal’s MST algorithm – constructs MST via edge sorting and greedy union.

- Union-Find (Disjoint Set Union) – used for cycle detection and efficient component merging.

- Path compression and union by rank for near-constant-time merges.

- Trade-offs between Kruskal and Prim:

    - Kruskal → better for sparse graphs with explicit edge lists.

    - Prim → better for dense graphs with adjacency structures.

- Real-world parallels:

    - Laying fiber optic networks with minimal total cost.

    - Designing efficient pipeline or rail systems.

    - Cluster merging in machine learning (hierarchical clustering).
