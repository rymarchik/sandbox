---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-07-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary
In addition to the previously documented problems, I incorporated several new algorithmic tasks that span topics such as dynamic programming, 
graph traversal, greedy strategies, and advanced data structures. Each problem was carefully selected to reinforce core computer science principles 
and expose users to different problem-solving paradigms.

## Minimal Number of Packages
```java
/**
 * A large package can hold 5 items, while a small package can hold only 1 item. The available number of both large and small
 * packages is limited. All items must be placed in packages and used packages can have empty space left.
 * Write a function that calculates the minimum number of packages needed to hold a given number of items. If it's not possible
 * to meet the requirements, return -1.
 * For example, if we have 13 items, 3 large and 10 small packages, the function should return 3 (3 large packages)
 */
public class MinimalNumberOfPackages {

    public static long minimalNumberOfPackages(long items, long availableLargePackages, long availableSmallPackages) {
        final int largePackageSize = 5;
        final int smallPackageSize = 2;

        long requiredLargePackages = (items + largePackageSize - 1) / largePackageSize;
        if (requiredLargePackages <= availableLargePackages) {
            return requiredLargePackages;
        }
        else {
            long remainingItems = items - availableLargePackages * largePackageSize;
            if (remainingItems > availableSmallPackages * smallPackageSize) {
                return -1;
            }
            long requiredSmallPackages = (remainingItems + smallPackageSize - 1) / smallPackageSize;
            return availableLargePackages + requiredSmallPackages;
        }
    }

    public static void case1() {
        System.out.println(minimalNumberOfPackages(13, 3, 10));
    }
}
```

## Palindrome
```java
/**
 * Utility class for checking whether a number or a string is a palindrome.
 *
 * A palindrome is a value that reads the same forward and backward.
 *
 * Supports:
 * - Integer input: checks if the number's digits form a palindrome.
 * - String input: checks if the characters form a palindrome (case-sensitive).
 *
 * Example:
 * - checkIfPalindrome(12321) → true
 * - checkIfPalindrome("racecar") → true
 * - checkIfPalindrome("hello") → false
 */
public class Palindrome {

    public static boolean checkIfPalindrome(int number) {
        List<Integer> numberList = new ArrayList<>();

        recursion(number, numberList);

        for (int i = 0; i < numberList.size() / 2; i++) {
            if (!numberList.get(i).equals(numberList.get(numberList.size() - 1 - i))) {
                return false;
            }
        }
        return true;
    }

    public static boolean checkIfPalindrome(String s) {
        if (s.length() == 1) {
            return true;
        }
        else {
            if (s.substring(0, 1).equals(s.substring(s.length() - 1))) {
                if (s.length() == 2) {
                    return true;
                }
                return checkIfPalindrome(s.substring(1, s.length() - 1));
            }
            else {
                return false;
            }
        }
    }

    private static void recursion(int n, List<Integer> numberList) {
        if (n < 10) {
            numberList.add(n);
        }
        else {
            numberList.add(n % 10);
            recursion(n / 10, numberList);
        }
    }

    public static void testPalindrome() {
        int num = 12345321;
        String str = "dad";
        System.out.println(checkIfPalindrome(num));
        System.out.println(checkIfPalindrome(str));
    }
}
```
## Discount
```java
/**
 * Given an array of items prices. Each price has discount price = previous item price. First item doesn't have any discount.
 * What is the final price customer has to pay after discount applied
 */
public class SumDiscounts {

    public static void discount(int[] prices) {
        int sumDiscounts = IntStream.range(1, prices.length)
            .map(i -> prices[i] - prices[i - 1])
            .reduce(prices[0], Integer::sum);
        System.out.println(sumDiscounts);
    }

    public static void discountInParallel(int[] prices) {
        int sumDiscounts = prices[0] + IntStream.range(1, prices.length)
            .parallel()
            .map(i -> prices[i] - prices[i - 1])
            .sum();
        System.out.println(sumDiscounts);
    }

    public static void case1() {
        int[] array = {100, 200, 300, 400};
        discount(array);
    }

    public static void case2() {
        int[] array = {100, 200, 300, 400};
        discountInParallel(array);
    }
}
```
## LeetCode 46. Permutations
### Backtracking – Recursion – DFS
Problem Summary:
Given an array of distinct integers, return all possible permutations.
```java
/**
 * Generates all permutations of a given array of distinct integers.
 * This is a classic backtracking problem.
 *
 * Time complexity: O(n * n!), where n is the number of elements.
 */
public class Permutations {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(nums, new ArrayList<>(), new boolean[nums.length], result);
        return result;
    }

    private void backtrack(int[] nums, List<Integer> current, boolean[] used, List<List<Integer>> result) {
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current)); // Found a valid permutation
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;

            current.add(nums[i]);
            used[i] = true;

            backtrack(nums, current, used, result);

            current.remove(current.size() - 1); // backtrack
            used[i] = false;
        }
    }

    public static void main(String[] args) {
        var solver = new Permutations();
        System.out.println(solver.permute(new int[]{1, 2, 3}));
    }
}
```
Concepts Covered:

Backtracking with state tracking (used[] array)

Recursion tree traversal

Deep copying of temporary lists to capture immutable states

## LeetCode 2. Add Two Numbers
### Linked List – Math – Simulation
Problem Summary:
Add two numbers represented as linked lists, where each node contains a single digit. The digits are stored in reverse order.
```java
/**
 * Adds two numbers represented by reversed linked lists.
 * Produces a new linked list representing the sum.
 *
 * Time complexity: O(max(n, m)), where n and m are lengths of the two lists.
 */
public class AddTwoNumbers {

    public static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0); // dummy head
        ListNode current = dummy;

        int carry = 0;

        // Traverse both lists
        while (l1 != null || l2 != null || carry > 0) {
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;

            int sum = x + y + carry;
            carry = sum / 10;

            current.next = new ListNode(sum % 10);
            current = current.next;

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return dummy.next;
    }

    // For testing
    public static void printList(ListNode node) {
        while (node != null) {
            System.out.print(node.val);
            if (node.next != null) System.out.print(" -> ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        AddTwoNumbers solver = new AddTwoNumbers();

        // [2 -> 4 -> 3] + [5 -> 6 -> 4] = [7 -> 0 -> 8]
        ListNode l1 = new ListNode(2);
        l1.next = new ListNode(4);
        l1.next.next = new ListNode(3);

        ListNode l2 = new ListNode(5);
        l2.next = new ListNode(6);
        l2.next.next = new ListNode(4);

        ListNode result = solver.addTwoNumbers(l1, l2);
        printList(result); // Output: 7 -> 0 -> 8
    }
}
```
Concepts Covered:

Linked list traversal

Carry-over simulation in digit-wise addition

Edge-case handling: different lengths, final carry

## LeetCode 347. Top K Frequent Elements
### HashMap – Heap – Bucket Sort
Problem Summary:
Add two numbers represented as linked lists, where each node contains a single digit. The digits are stored in reverse order.
```java
/**
 * Returns the k most frequent elements in the array.
 *
 * This solution uses a HashMap to count frequencies, and a PriorityQueue (min-heap)
 * to keep track of the top-k elements by frequency.
 *
 * Time complexity: O(n log k), where n is the number of elements in the input array.
 * Space complexity: O(n) for the frequency map and heap.
 */
public class TopKFrequentElements {

    public int[] topKFrequent(int[] nums, int k) {
        // Step 1: Count frequency of each number using a hash map.
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : nums) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }

        // Step 2: Use a min-heap to store the top-k elements by frequency.
        PriorityQueue<Map.Entry<Integer, Integer>> heap =
            new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));

        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            heap.offer(entry);
            if (heap.size() > k) {
                heap.poll(); // Remove the least frequent element
            }
        }

        // Step 3: Extract elements from the heap into result array.
        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = heap.poll().getKey();
        }

        // Since heap is unordered, the result order is not guaranteed.
        return result;
    }

    public static void main(String[] args) {
        TopKFrequentElements solver = new TopKFrequentElements();
        int[] result = solver.topKFrequent(new int[]{1,1,1,2,2,3}, 2);
        System.out.println(Arrays.toString(result)); // Output: [1, 2]
    }
}
```
Concepts Covered:

HashMap for frequency counting

Min-heap (PriorityQueue) to track top-k frequent values

Trade-off between memory and CPU efficiency

## LeetCode 3. Longest Substring Without Repeating Characters
### Sliding Window – HashMap
Problem Summary:
Find the length of the longest substring without repeating characters.
```java
/**
 * Finds the length of the longest substring without repeating characters using sliding window technique.
 *
 * Time complexity: O(n), where n is the length of the string.
 * Space complexity: O(k), where k is the character set size (at most 128 for ASCII).
 */
public class LongestUniqueSubstring {

    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> charIndexMap = new HashMap<>(); // Tracks latest index of each character
        int maxLen = 0;
        int start = 0; // Left boundary of the current window

        // Expand the right end of the window one character at a time
        for (int end = 0; end < s.length(); end++) {
            char currentChar = s.charAt(end);

            // If character already seen, move start pointer past the last occurrence
            if (charIndexMap.containsKey(currentChar)) {
                start = Math.max(start, charIndexMap.get(currentChar) + 1);
            }

            // Update the last seen index of the current character
            charIndexMap.put(currentChar, end);

            // Update max length of unique substring found so far
            maxLen = Math.max(maxLen, end - start + 1);
        }

        return maxLen;
    }

    public static void main(String[] args) {
        LongestUniqueSubstring solver = new LongestUniqueSubstring();
        System.out.println(solver.lengthOfLongestSubstring("abcabcbb")); // Output: 3 ("abc")
        System.out.println(solver.lengthOfLongestSubstring("bbbbb"));    // Output: 1 ("b")
        System.out.println(solver.lengthOfLongestSubstring("pwwkew"));   // Output: 3 ("wke")
    }
}
```
Concepts Covered:

Sliding window with dynamic left boundary

HashMap to track latest positions of characters

Efficient substring tracking without nested loops

## LeetCode 239. Sliding Window Maximum (Hard)
### Sliding Window – Monotonic Queue – Deque – Optimization
Problem Summary:
Given an array nums and an integer k, return the maximum value in each sliding window of size k.
```java
/**
 * Solves the sliding window maximum problem using a monotonic deque.
 * The deque stores indices of elements in decreasing order of their values.
 *
 * Time complexity: O(n), where n is the length of nums.
 * Each index is pushed and popped from deque at most once.
 */
public class SlidingWindowMaximum {

    /**
     * Returns an array of the maximum value in each sliding window of size k.
     *
     * @param nums Input array of integers.
     * @param k Size of the sliding window.
     * @return Array of maximums for each window.
     */
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) return new int[0];
        int n = nums.length;
        int[] result = new int[n - k + 1]; // One result per window
        int ri = 0;

        // Deque stores indices of useful elements in decreasing order
        Deque<Integer> deque = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            // Remove indices from the front if they are outside the current window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // Maintain decreasing order: remove smaller elements from the back
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            // Add current index to deque
            deque.offerLast(i);

            // Add result once the window reaches size k
            if (i >= k - 1) {
                result[ri++] = nums[deque.peekFirst()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        SlidingWindowMaximum solver = new SlidingWindowMaximum();
        int[] nums = {1,3,-1,-3,5,3,6,7};
        int k = 3;
        int[] result = solver.maxSlidingWindow(nums, k);
        System.out.println(Arrays.toString(result)); // [3, 3, 5, 5, 6, 7]
    }
}
```
Concepts Covered:

Monotonic Deque: Maintains a decreasing order of values (by index) inside the deque, allowing constant-time access to the current 
window's maximum.

Window Management: Elements that fall outside the current sliding window are promptly removed from the front of the deque to keep 
the window valid.

Lazy Removal: Elements are only removed from the deque when they exit the window range. There’s no need to recalculate the maximum 
eagerly — the structure ensures correctness passively.
