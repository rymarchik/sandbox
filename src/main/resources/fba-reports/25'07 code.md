---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-08-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary
In the past month, I further enriched the platform’s algorithmic and systems-oriented content by implementing and documenting two 
additional utility components focused on stream processing and real-time data simulation.

### CommandProcessor
A lightweight parser designed to interpret character streams as sequential arithmetic commands. The component emphasizes robustness 
and error handling in a low-level streaming context. It processes operations such as increment, decrement, doubling, and halving, 
while guarding against overflows and invalid input. The solution provides a concise example of stateful computation over character 
input, and demonstrates defensive programming practices through thorough exception handling.

As part of the documentation effort, the logic was explained with clear operational semantics and example inputs. Edge cases such 
as empty input streams and arithmetic limits were covered via custom exception scenarios.

### CurrencyExchanger
A simulation of a historical currency exchange service with time-based querying and scheduled updates. This task demonstrated the 
modeling of exchange rates as temporal data, leveraging TreeMap for efficient time-range queries and ScheduledExecutorService for 
automated periodic updates.

The component allows users to add and retrieve currency conversion rates for specific timestamps, emulating a simplified version 
of a financial market data system. Documentation focused on the design rationale behind the temporal data structures, conversion 
mechanics, and fault tolerance (e.g., missing or outdated rates).

The inclusion of a real-time update loop and historical lookups brings the system closer to real-world scenarios, offering future 
users an excellent pedagogical example of concurrent scheduling and temporal data indexing in Java.

## Command Processor
```java
/**
 * Utility class that processes a character stream of arithmetic commands.
 *
 * Each character in the input stream represents a simple operation on a long value:
 * - '+' → increment result by 1
 * - '-' → decrement result by 1
 * - '*' → multiply result by 2
 * - '/' → divide result by 2 (integer division)
 *
 * The result starts at 0 and is modified sequentially as characters are read.
 *
 * Throws:
 * - {@code ArithmeticException} if the result overflows or underflows during operations.
 * - {@code IllegalArgumentException} if an unknown character is encountered.
 * - {@code IllegalStateException} if the stream contains no characters.
 *
 * Example input stream: "+*+/" → result becomes 1 → 2 → 3 → 1
 */
public class CommandProcessor {

    public long process(Reader stream) throws IOException {
        long result = 0;
        boolean hasReadAnyChar = false;
        int character;
        while ((character = stream.read()) != -1) {
            hasReadAnyChar = true;
            char c = (char) character;
            switch (c) {
                case '+' -> {
                    if (result == Long.MAX_VALUE) {
                        throw new ArithmeticException("Result exceeded maximum value");
                    }
                    result++;
                }
                case '-' -> {
                    if (result == Long.MIN_VALUE) {
                        throw new ArithmeticException("Result exceeded minimum value");
                    }
                    result--;
                }
                case '*' -> {
                    if (result > Long.MAX_VALUE / 2) {
                        throw new ArithmeticException("Multiplication result exceeded maximum value");
                    }
                    result *= 2;
                }
                case '/' -> result /= 2;
                default -> throw new IllegalArgumentException("Unexpected character " + c);
            }
        }
        if (!hasReadAnyChar) {
            throw new IllegalStateException("No characters were read from the stream");
        }
        return result;
    }
}
```

## Currency Exchanger
```java
/**
 * Utility class for simulating a time-based currency exchange service.
 *
 * The exchanger stores historical exchange rates between currency pairs using timestamps.
 * It periodically updates rates to simulate data from an external API.
 *
 * Features:
 * - Add new exchange rates with timestamps.
 * - Query the most recent valid exchange rate for a specific time.
 * - Convert currency amounts using historical rates.
 * - Periodically auto-update rates every 2 seconds.
 *
 * Throws:
 * - {@code IllegalArgumentException} if no rates are available for a given currency pair.
 * - {@code IllegalStateException} if no rate exists for the requested timestamp.
 *
 * Example:
 * - convert("USD", "BYN", 100, LocalDateTime.of(2025, 1, 25, 18, 0))
 *   → returns the amount in BYN using the latest available rate before 18:00.
 */
public class CurrencyExchanger {

    private final Map<Pair<String, String>, TreeMap<LocalDateTime, Double>> exchangeRates = new HashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    public CurrencyExchanger() {
        startPeriodicRateUpdate();
    }

    private void addExchangeRate() {
        // имитация внешнего API
        addExchangeRate("USD", "BYN", 3.45 + Math.random() * 0.02, LocalDateTime.now());
        addExchangeRate("EUR", "BYN", 3.62 + Math.random() * 0.02, LocalDateTime.now());
        addExchangeRate("EUR", "USD", 1.18 + Math.random() * 0.02, LocalDateTime.now());
    }

    private void addExchangeRate(String fromCurrency, String toCurrency, double rate, LocalDateTime timestamp) {
        Pair<String, String> currencyPair = Pair.of(fromCurrency, toCurrency);
        exchangeRates
            .computeIfAbsent(currencyPair, k -> new TreeMap<>())
            .put(timestamp, rate);
    }

    public double getExchangeRate(String fromCurrency, String toCurrency, LocalDateTime timestamp) {
        Pair<String, String> currencyPair = Pair.of(fromCurrency, toCurrency);
        TreeMap<LocalDateTime, Double> rates = exchangeRates.get(currencyPair);

        if (rates == null || rates.isEmpty()) {
            throw new IllegalArgumentException("No exchange rates available for this currency pair.");
        }

        // Найти курс, актуальный для заданной временной метки
        Map.Entry<LocalDateTime, Double> entry = rates.floorEntry(timestamp);

        if (entry == null) {
            throw new IllegalStateException("No valid exchange rate found for the given time.");
        }

        return entry.getValue();
    }

    public double convert(String fromCurrency, String toCurrency, double amount, LocalDateTime timestamp) {
        double rate = getExchangeRate(fromCurrency, toCurrency, timestamp);
        return amount * rate;
    }

    private void startPeriodicRateUpdate() {
        scheduler.scheduleAtFixedRate(
            this::addExchangeRate,
            0,
            2,
            TimeUnit.SECONDS
        );
    }

    public void stopService() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            scheduler.shutdownNow();
        }
    }

    public static void case1() throws InterruptedException {
        CurrencyExchanger exchanger = new CurrencyExchanger();
        exchanger.addExchangeRate("USD", "BYN", 3.45, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("USD", "BYN", 3.47, LocalDateTime.of(2025, 1, 25, 17, 30));
        exchanger.addExchangeRate("USD", "BYN", 3.41, LocalDateTime.of(2025, 1, 26, 10, 15));
        exchanger.addExchangeRate("BYN", "USD", 0.29, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("EUR", "BYN", 3.62, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("BYN", "EUR", 0.27, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("USD", "EUR", 0.85, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("EUR", "USD", 1.18, LocalDateTime.of(2025, 1, 25, 13, 0));

        Thread.sleep(10000);

        exchanger.stopService();

        double convertedAmount = exchanger.convert("USD", "BYN", 100, LocalDateTime.of(2025, 1, 25, 18, 0));
        System.out.println(convertedAmount);
    }

}
```
## LeetCode 127. Word Ladder

### Graph – BFS – Shortest Path

Problem Summary:
Given two words (beginWord and endWord), and a dictionary (wordList), return the length of the shortest transformation sequence from beginWord to endWord. Each transformation must change exactly one letter and the resulting word must be in the wordList.

```java
/**
 * Solves the Word Ladder problem using BFS to find the shortest transformation sequence.
 * Time complexity: O(N * M^2), where N is the number of words and M is the length of each word.
 */
public class WordLadder {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>(wordList);
        if (!wordSet.contains(endWord)) return 0;

        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        int level = 1;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String current = queue.poll();
                for (int j = 0; j < current.length(); j++) {
                    char[] chars = current.toCharArray();
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (chars[j] == c) continue;
                        chars[j] = c;
                        String next = new String(chars);
                        if (next.equals(endWord)) return level + 1;
                        if (wordSet.contains(next) && !visited.contains(next)) {
                            visited.add(next);
                            queue.offer(next);
                        }
                    }
                }
            }
            level++;
        }
        return 0;
    }
}
```

Concepts Covered:

Graph modeling of word transformations
Breadth-first search (BFS) to find shortest path
Dynamic neighbor generation (not stored in advance)

---

## LeetCode 76. Minimum Window Substring

### Sliding Window – HashMap – Optimization

Problem Summary:
Given two strings s and t, return the minimum window in s which contains all the characters in t (including duplicates). If no such window exists, return the empty string.

```java
/**
 * Finds the smallest substring of s containing all characters of t using sliding window.
 * Time complexity: O(n), where n is the length of s.
 */
public class MinimumWindowSubstring {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        Map<Character, Integer> required = new HashMap<>();
        for (char c : t.toCharArray()) {
            required.put(c, required.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> window = new HashMap<>();
        int start = 0, matched = 0, minLen = Integer.MAX_VALUE, minStart = 0;

        for (int end = 0; end < s.length(); end++) {
            char rightChar = s.charAt(end);
            window.put(rightChar, window.getOrDefault(rightChar, 0) + 1);

            if (required.containsKey(rightChar) &&
                window.get(rightChar).intValue() == required.get(rightChar).intValue()) {
                matched++;
            }

            while (matched == required.size()) {
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    minStart = start;
                }

                char leftChar = s.charAt(start++);
                window.put(leftChar, window.get(leftChar) - 1);
                if (required.containsKey(leftChar) &&
                    window.get(leftChar).intValue() < required.get(leftChar).intValue()) {
                    matched--;
                }
            }
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }
}
```

Concepts Covered:

Sliding window with two pointers
HashMap frequency counting
Greedy shrinking of valid windows

---

## LeetCode 23. Merge k Sorted Lists

### Priority Queue – Linked List – Divide and Conquer

Problem Summary:
Merge k sorted linked lists into one sorted list and return it.

```java
/**
 * Uses a priority queue (min-heap) to merge k sorted linked lists.
 * Time complexity: O(N log k), where N is the total number of nodes.
 */
public class MergeKSortedLists {
    public static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }

    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> heap = new PriorityQueue<>(Comparator.comparingInt(n -> n.val));

        for (ListNode list : lists) {
            if (list != null) heap.offer(list);
        }

        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (!heap.isEmpty()) {
            ListNode minNode = heap.poll();
            current.next = minNode;
            current = current.next;
            if (minNode.next != null) heap.offer(minNode.next);
        }

        return dummy.next;
    }
}
```

Concepts Covered:

Min-heap for efficient minimum retrieval
Linked list traversal and building
Time-space tradeoffs for external sorting

---

## LeetCode 15. 3Sum

### Two Pointers – Sorting – Set

Problem Summary:
Given an integer array nums, return all the unique triplets \[nums\[i], nums\[j], nums\[k]] such that their sum is zero.

```java
/**
 * Finds all unique triplets in the array that sum to zero.
 * Time complexity: O(n^2), after sorting.
 */
public class ThreeSum {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicates

            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }
}
```

Concepts Covered:

Sorting to simplify duplicate handling
Two-pointer search for fixed first element
Avoiding repeated triplets via skipping

---

## LeetCode 84. Largest Rectangle in Histogram

### Stack – Monotonic Stack – Greedy

Problem Summary:
Given an array of integers representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed.

```java
/**
 * Solves the Largest Rectangle in Histogram using a monotonic increasing stack.
 * Time complexity: O(n), where n is the number of bars.
 */
public class LargestRectangleHistogram {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int n = heights.length;

        for (int i = 0; i <= n; i++) {
            int currHeight = (i == n) ? 0 : heights[i];
            while (!stack.isEmpty() && currHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            stack.push(i);
        }

        return maxArea;
    }
}
```

Concepts Covered:

Monotonic stack to maintain increasing heights
Greedy area expansion with width tracking
Sentinel value handling via index overflow

---

## LeetCode 42. Trapping Rain Water

### Two Pointers – Array – Dynamic Programming

Problem Summary:
Given an array of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

This problem models the real-world scenario of calculating water retention between barriers (think urban drainage or terrain water accumulation). It requires understanding how to efficiently determine boundaries on both sides for every position to find trapped water volume.

```java
/**
 * Given an array representing elevation heights where the width of each bar is 1,
 * this class calculates how much water can be trapped after raining.
 *
 * The solution uses a two-pointer approach:
 * - Two pointers start from both ends of the array and move towards the center.
 * - Track the maximum height from the left and right sides.
 * - At each step, water trapped depends on the difference between the current height and the max boundary height.
 * - By moving pointers inward and updating boundaries, the trapped water is accumulated efficiently.
 *
 * Key points:
 * - Time complexity: O(n), each element is visited once.
 * - Space complexity: O(1), uses constant extra space.
 * - Efficient for large datasets without additional data structures.
 *
 * Practical use cases include simulating water flow, analyzing terrain or building landscapes,
 * and solving classic interview problems related to arrays and two-pointer techniques.
 */
public class TrappingRainWater {

    public int trap(int[] height) {
        if (height == null || height.length == 0) return 0;

        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        int trappedWater = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    trappedWater += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    trappedWater += rightMax - height[right];
                }
                right--;
            }
        }

        return trappedWater;
    }

    public static void main(String[] args) {
        TrappingRainWater solver = new TrappingRainWater();
        int[] elevationMap = {0,1,0,2,1,0,1,3,2,1,2,1};
        System.out.println(solver.trap(elevationMap)); // Output: 6
    }
}
```
Key challenges include:

Handling elevation boundaries from both sides simultaneously.

Optimizing to avoid a naive O(n²) solution by precomputing or using two-pointer techniques.

Understanding the problem’s connection to prefix/suffix maxima and how water volume depends on the minimum boundary height.

Concepts Covered:

Two-pointer technique for linear-time traversal.

Dynamic programming via prefix and suffix maximum arrays.

Optimization of space/time trade-offs.

Problem-solving with constraints on array traversal.
