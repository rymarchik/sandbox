---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-09-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary

During this month, significant progress was made in expanding the algorithmic task library with advanced LeetCode problems, primarily focusing on **Hard-level challenges**. The main objective was not only to solve these problems but also to provide **comprehensive documentation, detailed code analysis, and real-world context** for each solution, ensuring educational value for future users.

The five tasks addressed included:

1. **LeetCode 295 – Find Median from Data Stream**
    - Implemented a **median tracker** using two heaps (max-heap and min-heap) to maintain a running median efficiently.
    - Highlighted techniques for **balancing dynamic data structures** in real-time to compute aggregate statistics.
    - Applications: real-time analytics, financial data streams, sensor data monitoring, and any domain requiring online statistical computation.
2. **LeetCode 224 – Basic Calculator**
    - Focused on parsing and evaluating expressions with nested parentheses and additive operators.
    - Emphasized stack-based state management and handling of sign scopes in dynamic expression evaluation.
    - Applications: interpreters, config evaluators, DSL parsers, and simplified arithmetic engines.

3. **LeetCode 297 – Serialize and Deserialize Binary Tree**
    - Covered techniques to convert tree structures into a string and reconstruct them losslessly.
    - Explored **preorder traversal** with null markers and recursive reconstruction strategies.
    - Real-world usage: persistent storage, network transmission of hierarchical data, and distributed systems.

4. **LeetCode 10 – Regular Expression Matching**
    - Applied **dynamic programming** to implement regex matching with `.` and `*`.
    - Demonstrated advanced pattern matching, state compression, and recurrence relation reasoning.
    - Applications: custom regex engines, text search, parsers, and pattern validation.

5. **LeetCode 212 – Word Search II**
    - Combined **Trie structures with backtracking** to perform efficient multi-word search in a 2D grid.
    - Showcased pruning techniques to reduce search space drastically.
    - Practical usage: word games, OCR pattern recognition, and 2D multi-pattern detection.

**Key Achievements:**
- Expanded understanding of **complex problem-solving strategies**, including DFS, BFS, DP, Trie usage, sliding windows, and two-pointer techniques.
- Strengthened ability to **write optimized, maintainable, and well-documented Java solutions**, with extensive inline commentary.
- Highlighted **real-world applicability** of algorithmic concepts in areas such as interpreters, search engines, gaming, and data processing.
- Each task includes not only a working solution but also a clear explanation of the algorithmic principles and rationale behind design choices.

**Impact on Algorithmic Task Library:**
- These five advanced tasks significantly enrich the library with **Hard-level problems**, offering both depth and variety.
- Provides learners with concrete examples of **problem decomposition, algorithm selection, and efficient implementation**.
- Serves as a reference for **best practices in documenting solutions** with educational clarity.

Overall, this month’s focus on advanced algorithmic challenges has **strengthened the platform’s repository**, making it a more comprehensive resource for both practice and instruction in complex problem-solving.

## LeetCode 295. Find Median from Data Stream

### Heap – Two Heaps – Online Algorithms

Problem Summary:
Design a data structure that supports adding numbers from a data stream and finding the median of the numbers seen so far. Operations:
- `addNum(int num)` — add a number to the data structure.
- `findMedian()` — return the median of all elements so far.

This problem is about building an **online** algorithm: data arrives incrementally and we must be able to answer queries (median) at any time with good bounds on time and space.

**Why it matters / Problems it solves:**
- Real-time statistics on streaming data (latency-sensitive): e.g., median response time, median price, median sensor value.
- Useful in telemetry, financial tick processing, monitoring dashboards where you need rolling medians without storing everything.
- Demonstrates how to maintain order-statistics efficiently with limited memory by splitting the dataset into two heaps.

**Approach overview:**
Maintain two heaps:
- Max-heap `low` — holds the smaller half of numbers (root = max of lower half).
- Min-heap `high` — holds the larger half of numbers (root = min of upper half).
  Keep sizes balanced (difference ≤ 1). Median is either root of one heap or average of both roots.

**Java Solution:**
```java
/**
 * Streaming median finder using two heaps.
 * - maxHeap (low) keeps the lower half (largest at top)
 * - minHeap (high) keeps the upper half (smallest at top)
 *
 * addNum: O(log n) due to heap operations
 * findMedian: O(1)
 */
public class MedianFinder {
    private final PriorityQueue<Integer> low;  // max-heap
    private final PriorityQueue<Integer> high; // min-heap

    public MedianFinder() {
        low = new PriorityQueue<>(Comparator.reverseOrder());
        high = new PriorityQueue<>();
    }

    public void addNum(int num) {
        // Push onto one heap then rebalance to maintain invariants.
        if (low.isEmpty() || num <= low.peek()) {
            low.offer(num);
        } else {
            high.offer(num);
        }

        // Rebalance sizes: ensure |size(low) - size(high)| <= 1
        if (low.size() > high.size() + 1) {
            high.offer(low.poll());
        } else if (high.size() > low.size() + 1) {
            low.offer(high.poll());
        }
    }

    public double findMedian() {
        if (low.size() == high.size()) {
            if (low.isEmpty()) return 0.0; // no elements
            // average of two middle values
            return (low.peek() + high.peek()) / 2.0;
        } else if (low.size() > high.size()) {
            return low.peek();
        } else {
            return high.peek();
        }
    }

    // Example usage and simple test
    public static void main(String[] args) {
        MedianFinder mf = new MedianFinder();
        mf.addNum(1);
        mf.addNum(2);
        System.out.println(mf.findMedian()); // 1.5
        mf.addNum(3);
        System.out.println(mf.findMedian()); // 2
    }
}
```
Concepts Covered:

Two-heap technique for order-statistics on streams

Online algorithms and amortized complexity

Practical trade-offs: memory vs latency (no full sort, only O(n) storage but balanced)

---

## LeetCode 224. Basic Calculator
### Stack – Expression Parsing – Recursion Simulation

**Problem Summary:**  
Implement a basic calculator to evaluate a simple expression string containing non-negative integers, `+`, `-`, `(`, `)`, and spaces.  
The expression grammar has only addition and subtraction with parentheses (no multiplication/division).

**Why it matters / Problems it solves:**
- Parsing and evaluating expressions is a core CS skill — appears in interpreters, config evaluators, and DSLs.
- Shows how to convert infix expressions with parentheses into an evaluable form without building a full AST.
- Teaches stack-based handling of state when entering/exiting parenthesis contexts and how to manage sign scopes.

**Approach overview:**
- Scan left-to-right, maintain:
    - Current result and current number under construction.
    - Current sign (`+1` or `-1`).
- Use a stack to push current result and sign when encountering `'('` and restore when encountering `')'`.
- This avoids building tokens/AST and evaluates in **O(n)** time and **O(n)** stack space for parentheses nesting.

**Java Solution:**
```java
/**
 * Basic calculator that evaluates expressions with +, -, parentheses and spaces.
 *
 * Core idea:
 * - Maintain current result and current sign.
 * - Build multi-digit numbers on the fly.
 * - On '(', push current result and sign to stack, reset them.
 * - On ')', finish current number, pop sign and accumulated result and combine.
 *
 * Time complexity: O(n)
 * Space complexity: O(n) for the stack in worst case (nested parentheses).
 */
public class BasicCalculator {
    public int calculate(String s) {
        int n = s.length();
        Deque<Integer> stack = new ArrayDeque<>();
        int result = 0;   // running total
        int number = 0;   // current number being formed
        int sign = 1;     // current sign: 1 or -1

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);

            if (Character.isDigit(c)) {
                // build the multi-digit number
                number = number * 10 + (c - '0');
            } else if (c == '+') {
                result += sign * number;
                number = 0;
                sign = 1;
            } else if (c == '-') {
                result += sign * number;
                number = 0;
                sign = -1;
            } else if (c == '(') {
                // push current state and reset for new sub-expression
                stack.push(result);
                stack.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                // finish current number, apply to result
                result += sign * number;
                number = 0;
                // pop sign and previous result
                int prevSign = stack.pop();
                int prevResult = stack.pop();
                result = prevResult + prevSign * result;
            } else {
                // ignore spaces and other whitespace
            }
        }

        // Add any remaining number
        if (number != 0) result += sign * number;
        return result;
    }

    public static void main(String[] args) {
        BasicCalculator calc = new BasicCalculator();
        System.out.println(calc.calculate("1 + 1")); // 2
        System.out.println(calc.calculate(" 2-1 + 2 ")); // 3
        System.out.println(calc.calculate("(1+(4+5+2)-3)+(6+8)")); // 23
    }
}
```
Concepts Covered:

On-the-fly tokenization (digit assembly)

Stack to store previous computation state across parentheses

Sign management and numeric accumulation

Practical Notes:

Extensible to support multiplication/division by switching to operator precedence strategies (shunting-yard, two-stack).

Robust under heavy nesting; important to consider stack overflow only for pathological inputs.

---

## LeetCode 297. Serialize and Deserialize Binary Tree
### Tree – Traversal – Encodings

**Problem Summary:**  
Design an algorithm to serialize a binary tree to a string and deserialize the string back to the original tree structure.  
The serialization/deserialization must be **lossless**, preserving the exact tree topology and node values.

**Why it matters / Problems it solves:**
- Enables **persistent storage** and **network transmission** of tree-structured data.
- Common in **distributed systems** where tree snapshots must be transferred or saved.
- Foundation for implementing **custom wire formats** or **domain-specific serializations**.
- Teaches concepts in **tree traversal**, **state encoding**, and **recursive reconstruction**.

**Approach overview:**
- Use **preorder traversal** with explicit null markers.
    - Serialize: traverse the tree recursively, appending node values and a sentinel (e.g., `#`) for null children.
    - Deserialize: read the serialized tokens and rebuild the tree recursively, respecting null markers.
- Alternate solutions: level-order traversal (BFS) with null markers is also valid.
- Preorder is compact and maps naturally to recursion, making it intuitive for reconstruction.

**Java Solution:**
```java
/**
 * Serialize and deserialize a binary tree using preorder traversal with null markers.
 *
 * - serialize: recursive preorder; append value or '#' for null.
 * - deserialize: use a queue of tokens and recursively rebuild nodes.
 *
 * Time complexity for both operations: O(n)
 * Space complexity: O(n) for output string and recursion stack.
 */
public class Codec {
    private static final String SEP = ",";
    private static final String NULL = "#";

    // Tree node definition
    public static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int x) { val = x; }
    }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        buildString(root, sb);
        return sb.toString();
    }

    private void buildString(TreeNode node, StringBuilder sb) {
        if (node == null) {
            sb.append(NULL).append(SEP);
            return;
        }
        sb.append(node.val).append(SEP);
        buildString(node.left, sb);
        buildString(node.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || data.isEmpty()) return null;
        Deque<String> tokens = new ArrayDeque<>(Arrays.asList(data.split(SEP)));
        return buildTree(tokens);
    }

    private TreeNode buildTree(Deque<String> tokens) {
        String token = tokens.poll();
        if (token.equals(NULL)) return null;
        TreeNode node = new TreeNode(Integer.parseInt(token));
        node.left = buildTree(tokens);
        node.right = buildTree(tokens);
        return node;
    }

    // Quick test
    public static void main(String[] args) {
        Codec codec = new Codec();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(4);
        root.right.right = new TreeNode(5);

        String s = codec.serialize(root);
        System.out.println(s); // Example output: "1,2,#,#,3,4,#,#,5,#,#,"

        TreeNode recovered = codec.deserialize(s);
        System.out.println(codec.serialize(recovered)); // Should match s
    }
}
```
Concepts Covered:

Tree traversal and explicit null representation

Deterministic, reversible encodings for structured data

Practical serialization choices: compactness vs readability

Notes:

Choose separator carefully if node values can include special characters.

For production, consider binary formats and length-prefixing to avoid expensive string splits.

---

## LeetCode 10. Regular Expression Matching
### Dynamic Programming – Pattern Matching – Complex State

**Problem Summary:**  
Implement regular expression matching with support for `.` (matches any single character) and `*` (matches zero or more of the preceding element).  
Given `s` (input string) and `p` (pattern), determine if `s` matches `p` **entirely**.

**Why it matters / Problems it solves:**
- Deepens understanding of **pattern matching internals**, useful for building search engines, parsers, or simplified regex engines.
- Demonstrates reasoning about **complex recurrence relations** and **state transitions** involving wildcards and repetition.
- Teaches **dynamic programming** over pairs of indices (string index, pattern index), including techniques for **state compression** and optimization.
- Highlights common strategies in string processing, text search, and automated pattern validation tasks.

**Approach overview:**
- Construct a DP table `dp[i][j]` indicating whether `s[i:]` matches `p[j:]`.
- Fill the table **bottom-up**, considering the following:
    - `.` matches any single character.
    - `*` can match zero occurrences of the preceding element or one/more occurrences if the first character matches.
- The final result is stored in `dp[0][0]`, representing whether the entire string matches the entire pattern.

**Java Solution:**

```java
/**
 * Regular expression matcher with '.' and '*'.
 *
 * - dp[i][j] indicates whether s[i:] matches p[j:].
 * - Base: dp[m][n] = true (empty matches empty).
 * - Transition:
 *   - firstMatch = i < m && (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')
 *   - if pattern has '*' at j+1: dp[i][j] = dp[i][j+2] || (firstMatch && dp[i+1][j])
 *   - else: dp[i][j] = firstMatch && dp[i+1][j+1]
 *
 * Time complexity: O(m * n)
 * Space complexity: O(m * n) (can be optimized)
 */
public class RegexMatching {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[m][n] = true;

        // Fill table bottom-up
        for (int i = m; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                boolean firstMatch = (i < m) &&
                    (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.');

                if (j + 1 < n && p.charAt(j + 1) == '*') {
                    // Skip '*' (zero occurrence) or use one occurrence if first matches
                    dp[i][j] = dp[i][j + 2] || (firstMatch && dp[i + 1][j]);
                } else {
                    dp[i][j] = firstMatch && dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];
    }

    public static void main(String[] args) {
        RegexMatching rm = new RegexMatching();
        System.out.println(rm.isMatch("aa", "a")); // false
        System.out.println(rm.isMatch("aa", "a*")); // true
        System.out.println(rm.isMatch("ab", ".*")); // true
        System.out.println(rm.isMatch("aab", "c*a*b")); // true
    }
}
```
Concepts Covered:

2D dynamic programming for pattern matching

Handling special operators (. and *) via recurrence

Trade-offs between recursive memoization and iterative DP

Practical considerations:

Production regex engines are far more complex (backtracking engines, NFA/DFA), but this problem captures core DP reasoning and edge cases.

Watch for performance pitfalls: naive backtracking can be exponential; DP guarantees polynomial time.

---

## LeetCode 212. Word Search II
### Trie – Backtracking – DFS – Pruning

**Problem Summary:**  
Given a 2D board of characters and a list of words, find all words on the board.  
Words are formed by sequentially adjacent cells (horizontal/vertical), and the same cell **cannot** be used more than once in a word.  
Return all words from the given list that appear on the board.

**Why it matters / Problems it solves:**
- Efficient **multi-pattern search** in a 2D grid: a naive search per word is extremely expensive.
- Practical use cases include **Boggle solvers**, word-finding games, and **multi-pattern detection in 2D datasets** (like puzzles, matrices of data, or OCR output).
- Demonstrates a combination of **prefix indexing (Trie)** with **backtracking** and **heavy pruning** for performance optimization.
- Illustrates the power of combining **DFS traversal with prefix-based constraints** to avoid unnecessary computation.

**Approach overview:**
1. Build a **Trie** from the word list, allowing quick prefix checks during board traversal.
2. For each cell on the board, start a **DFS** traversal:
    - Walk down the trie while exploring neighboring cells.
    - If the current path is **not a prefix** of any word in the trie, **prune** immediately.
    - When a trie node marks a **word end**, add it to the results. Optionally remove the word marker to avoid duplicates.
3. Maintain a visited state for each cell to ensure no cell is used more than once in the current path.

**Java Solution:**

```java
/**
 * Word Search II: build Trie for all words and DFS from each board cell.
 *
 * Key optimizations:
 * - Trie allows O(1) prefix check during DFS.
 * - Mark found words in Trie to avoid duplicates.
 * - In-place marking of board cells as visited with char swap or sentinel.
 *
 * Time complexity: worst-case high, but practical performance is good with pruning.
 */
public class WordSearchII {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        String word; // non-null if node represents end of a word
    }

    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = buildTrie(words);
        List<String> res = new ArrayList<>();

        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dfs(board, i, j, root, res);
            }
        }
        return res;
    }

    private void dfs(char[][] board, int i, int j, TrieNode node, List<String> res) {
        char c = board[i][j];
        if (c == '#' || node.next[c - 'a'] == null) return;
        node = node.next[c - 'a'];
        if (node.word != null) {
            res.add(node.word);
            node.word = null; // deduplicate
        }

        board[i][j] = '#'; // mark visited
        int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length) {
                dfs(board, x, y, node, res);
            }
        }
        board[i][j] = c; // restore
    }

    private TrieNode buildTrie(String[] words) {
        TrieNode root = new TrieNode();
        for (String w : words) {
            TrieNode cur = root;
            for (char ch : w.toCharArray()) {
                int idx = ch - 'a';
                if (cur.next[idx] == null) cur.next[idx] = new TrieNode();
                cur = cur.next[idx];
            }
            cur.word = w; // store word at terminal node
        }
        return root;
    }

    public static void main(String[] args) {
        WordSearchII solver = new WordSearchII();
        char[][] board = {
            {'o','a','a','n'},
            {'e','t','a','e'},
            {'i','h','k','r'},
            {'i','f','l','v'}
        };
        String[] words = {"oath","pea","eat","rain"};
        System.out.println(solver.findWords(board, words)); // [oath, eat] (order may vary)
    }
}
```

Concepts Covered:

Trie (prefix tree) for multi-pattern search

Backtracking (DFS) with aggressive pruning using Trie

In-place visitation marking to avoid extra memory per search path

Deduplication by clearing word in trie node when found

Practical notes:

For very large word lists, memory for the Trie matters — consider compressed tries or iterative filters.

Can be extended for diagonal moves or other adjacency rules with minor modifications.
