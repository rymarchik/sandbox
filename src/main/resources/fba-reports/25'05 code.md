---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-06-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary
Over the past month, I continued expanding the platform’s algorithmic task library by solving and documenting additional LeetCode problems across various difficulty levels.
The focus remained on diversifying the collection to cover a broader range of fundamental algorithmic concepts.
Each task was thoroughly analyzed and accompanied by comprehensive editorial notes and test cases, ensuring clarity and pedagogical value for future users.

## Leetcode 289. Game of Life (Medium)
```java
/**
 * Implement the Game of Life logic on a 2D grid, where each cell is either alive ('1') or dead ('0').
 * Each cell's next state is determined by the number of live neighbors, following these rules:
 * - Underpopulation: A live cell with fewer than two live neighbors dies.
 * - Survival: A live cell with two or three live neighbors lives on.
 * - Overpopulation: A live cell with more than three live neighbors dies.
 * - Reproduction: A dead cell with exactly three live neighbors becomes a live cell.
 * This implementation works on a flattened string representation of the board, where rows are separated by underscores (_).
 * Example: "010_001_111" represents a 3x3 grid.
 */
public class GameOfLife_289 {

    public static String gameOfLifeStrings(String str) {
        // Split the input string into rows based on underscores
        String[] strArray = str.split("_");
        int rows = strArray.length;
        int cols = strArray[0].length();

        // Create two board representations: one for reading, one for writing
        char[][] originalBoard = new char[rows][cols];
        char[][] copyBoard = new char[rows][cols];

        // Fill both boards with initial state
        for (int i = 0; i < rows; i++) {
            originalBoard[i] = strArray[i].toCharArray();
            copyBoard[i] = strArray[i].toCharArray();
        }

        // Iterate over each cell in the board
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int liveMates = 0;

                // Check all 8 neighbors
                for (int i = -1; i <= 1; i++) {
                    for (int j = -1; j <= 1; j++) {
                        // Skip the cell itself
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        int rowMate = row + i;
                        int colMate = col + j;

                        // Count valid live neighbors
                        if ((rowMate < rows && rowMate >= 0) && (colMate < cols && colMate >= 0) && copyBoard[rowMate][colMate] == '1') {
                            liveMates++;
                        }
                    }
                }

                // Apply Game of Life rules
                if (copyBoard[row][col] == '0' && liveMates == 3) {
                    // Reproduction
                    originalBoard[row][col] = '1';
                }
                if (copyBoard[row][col] == '1' && (liveMates < 2 || liveMates > 3)) {
                    // Underpopulation or Overpopulation
                    originalBoard[row][col] = '0';
                }
                // Else: cell remains unchanged
            }
        }

        // Convert the updated board back into string format
        for (int i = 0; i < rows; i++) {
            strArray[i] = new String(originalBoard[i]);
        }
        str = String.join("_", strArray);
        return str;
    }
}
```

## SQL: Find the Oldest Age per Name
```java
/**
 * SELECT name, age from Person GROUP BY name HAVING MAX(age)
 */
public class TopAgeForName {

    /**
     * Solution using Map
     */
    public static List<Person> getTopAgeForNameUsingMap(List<Person> persons) {
        Map<String, Integer> resultMap = new HashMap<>();
        for (Person p : persons) {
            if (!resultMap.containsKey(p.getName()) || resultMap.get(p.getName()) < p.getAge()) {
                resultMap.put(p.getName(), p.getAge());
            }
        }
        return resultMap.entrySet().stream()
            .map(entry -> new Person(entry.getKey(), entry.getValue()))
            .toList();
    }

    /**
     * Solution using Set
     */
    public static List<Person> getTopAgeForNameUsingSet(List<Person> persons) {
        Set<Person> resultSet = new HashSet<>();
        Set<String> uniqueNames = new HashSet<>();
        for (Person person : persons) {
            if (uniqueNames.contains(person.getName())) {
                continue;
            }
            Person oldestPerson = persons.stream()
                .filter(p -> p.getName().equals(person.getName()))
                .sorted()
                .findFirst()
                .orElseThrow();
            resultSet.add(oldestPerson);
            uniqueNames.add(oldestPerson.getName());
        }
        return new ArrayList<>(resultSet);
    }

    /**
     * Solutions using Stream API
     */
    public static List<Person> getTopAgeForNameUsingStreams(List<Person> persons) {
        List<Person> resultListOption1 = persons.stream()
            .collect(Collectors.toMap(Person::getName, Person::getAge, Integer::max))
            .entrySet().stream()
            .map(entry -> new Person(entry.getKey(), entry.getValue()))
            .toList();

        List<Person> resultListOption2 = persons.stream()
            .collect(Collectors.groupingBy(Person::getName, Collectors.collectingAndThen(
                Collectors.maxBy(Comparator.comparingInt(Person::getAge)), Optional::get)))
            .values().stream()
            .toList();
        
        // Preferable
        List<Person> resultListOption3 = persons.stream()
            .collect(Collectors.toMap(Person::getName, Function.identity(),
                BinaryOperator.maxBy(Comparator.comparingInt(Person::getAge))))
            .values().stream()
            .toList();

        return resultListOption3;
    }

    public static void testTopAgeForName() {
        List<Person> persons = List.of(
            new Person("Alex", 10),
            new Person("Dima", 13),
            new Person("Alex", 17),
            new Person("Leha", 22),
            new Person("Dima", 15),
            new Person("Alex", 9),
            new Person("Alex", 20),
            new Person("Dima", 2));
        List<Person> topAgeForName = getTopAgeForNameByChatGPT(persons);
        for (Person p : topAgeForName) {
            System.out.println(p);
        }
    }
}
```
## Find the Third Non-Repeated Character in a String
```java
public class ThirdNonRepeatedCharacter {

    public static void findThirdNonRepeatedChar() {
        String s = "aaabbbgfeedccn";
        Optional<Character> result = alternativeFindThirdNonRepeatedChar(s);

        result.ifPresentOrElse(
            c -> System.out.println("The third non-repeated character is: " + c),
            () -> System.out.println("There are less than three non-repeated characters in the string.")
        );
    }

    public static Optional<Character> findThirdNonRepeatedChar(String s) {
        // Step 1: Count the occurrences of each character using LinkedHashMap to maintain insertion order
        Map<Character, Integer> frequency = new LinkedHashMap<>();
        for (char c : s.toCharArray()) {
            frequency.put(c, frequency.getOrDefault(c, 0) + 1);
        }

        // Step 2 and Step 3: Use streams to find the third non-repeated character
        return frequency.entrySet().stream()
            .filter(entry -> entry.getValue() == 1) // Filter non-repeated characters
            .map(Map.Entry::getKey) // Get the character
            .skip(2) // Skip the first two non-repeated characters
            .findFirst(); // Get the third non-repeated character
    }

    public static Optional<Character> alternativeFindThirdNonRepeatedChar(String s) {
        // s.chars() предпочтительнее, чем Stream.of(s.toCharArray()), и не создает дополнительный объект (массив)
        return s.chars()
            .mapToObj(c -> (char) c) // Convert ASCII codes to characters
            .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
            .entrySet().stream()
            .filter(entry -> entry.getValue() == 1) // Filter non-repeated characters
            .map(Map.Entry::getKey) // Get the character
            .skip(2) // Skip the first two non-repeated characters
            .findFirst(); // Get the third non-repeated character
    }
}
```