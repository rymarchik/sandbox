---
title: "AlgoMaster Monthly Report"
author: "Aliaksandr Rymarchyk"
date: "2025-12-01"
fontsize: 11pt
mainfont: "Roboto"
monofont: "Consolas"
geometry: margin=2cm
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere=true,commandchars=\\\{\},fontsize=\small}
  - \usepackage[russian,english]{babel}
---

## Monthly Progress Summary
Over the past month, I expanded the platform’s algorithmic and systems-focused scope by developing and documenting two new utility modules designed for stream processing and real-time data simulation.

## LeetCode 42. Trapping Rain Water

### Two Pointers – Array – Dynamic Programming

Problem Summary:
Given an array of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

This problem models the real-world scenario of calculating water retention between barriers (think urban drainage or terrain water accumulation). It requires understanding how to efficiently determine boundaries on both sides for every position to find trapped water volume.

```java
/**
 * Given an array representing elevation heights where the width of each bar is 1,
 * this class calculates how much water can be trapped after raining.
 *
 * The solution uses a two-pointer approach:
 * - Two pointers start from both ends of the array and move towards the center.
 * - Track the maximum height from the left and right sides.
 * - At each step, water trapped depends on the difference between the current height and the max boundary height.
 * - By moving pointers inward and updating boundaries, the trapped water is accumulated efficiently.
 *
 * Key points:
 * - Time complexity: O(n), each element is visited once.
 * - Space complexity: O(1), uses constant extra space.
 * - Efficient for large datasets without additional data structures.
 *
 * Practical use cases include simulating water flow, analyzing terrain or building landscapes,
 * and solving classic interview problems related to arrays and two-pointer techniques.
 */
public class TrappingRainWater {

    public int trap(int[] height) {
        if (height == null || height.length == 0) return 0;

        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        int trappedWater = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    trappedWater += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    trappedWater += rightMax - height[right];
                }
                right--;
            }
        }

        return trappedWater;
    }

    public static void main(String[] args) {
        TrappingRainWater solver = new TrappingRainWater();
        int[] elevationMap = {0,1,0,2,1,0,1,3,2,1,2,1};
        System.out.println(solver.trap(elevationMap)); // Output: 6
    }
}
```
Key challenges include:

Handling elevation boundaries from both sides simultaneously.

Optimizing to avoid a naive O(n²) solution by precomputing or using two-pointer techniques.

Understanding the problem’s connection to prefix/suffix maxima and how water volume depends on the minimum boundary height.

Concepts Covered:

Two-pointer technique for linear-time traversal.

Dynamic programming via prefix and suffix maximum arrays.

Optimization of space/time trade-offs.

Problem-solving with constraints on array traversal.

---

## Command Processor
```java
/**
 * Utility class that processes a character stream of arithmetic commands.
 *
 * Each character in the input stream represents a simple operation on a long value:
 * - '+' → increment result by 1
 * - '-' → decrement result by 1
 * - '*' → multiply result by 2
 * - '/' → divide result by 2 (integer division)
 *
 * The result starts at 0 and is modified sequentially as characters are read.
 *
 * Throws:
 * - {@code ArithmeticException} if the result overflows or underflows during operations.
 * - {@code IllegalArgumentException} if an unknown character is encountered.
 * - {@code IllegalStateException} if the stream contains no characters.
 *
 * Example input stream: "+*+/" → result becomes 1 → 2 → 3 → 1
 */
public class CommandProcessor {

    public long process(Reader stream) throws IOException {
        long result = 0;
        boolean hasReadAnyChar = false;
        int character;
        while ((character = stream.read()) != -1) {
            hasReadAnyChar = true;
            char c = (char) character;
            switch (c) {
                case '+' -> {
                    if (result == Long.MAX_VALUE) {
                        throw new ArithmeticException("Result exceeded maximum value");
                    }
                    result++;
                }
                case '-' -> {
                    if (result == Long.MIN_VALUE) {
                        throw new ArithmeticException("Result exceeded minimum value");
                    }
                    result--;
                }
                case '*' -> {
                    if (result > Long.MAX_VALUE / 2) {
                        throw new ArithmeticException("Multiplication result exceeded maximum value");
                    }
                    result *= 2;
                }
                case '/' -> result /= 2;
                default -> throw new IllegalArgumentException("Unexpected character " + c);
            }
        }
        if (!hasReadAnyChar) {
            throw new IllegalStateException("No characters were read from the stream");
        }
        return result;
    }
}
```

## Currency Exchanger
```java
/**
 * Utility class for simulating a time-based currency exchange service.
 *
 * The exchanger stores historical exchange rates between currency pairs using timestamps.
 * It periodically updates rates to simulate data from an external API.
 *
 * Features:
 * - Add new exchange rates with timestamps.
 * - Query the most recent valid exchange rate for a specific time.
 * - Convert currency amounts using historical rates.
 * - Periodically auto-update rates every 2 seconds.
 *
 * Throws:
 * - {@code IllegalArgumentException} if no rates are available for a given currency pair.
 * - {@code IllegalStateException} if no rate exists for the requested timestamp.
 *
 * Example:
 * - convert("USD", "BYN", 100, LocalDateTime.of(2025, 1, 25, 18, 0))
 *   → returns the amount in BYN using the latest available rate before 18:00.
 */
public class CurrencyExchanger {

    private final Map<Pair<String, String>, TreeMap<LocalDateTime, Double>> exchangeRates = new HashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    public CurrencyExchanger() {
        startPeriodicRateUpdate();
    }

    private void addExchangeRate() {
        // имитация внешнего API
        addExchangeRate("USD", "BYN", 3.45 + Math.random() * 0.02, LocalDateTime.now());
        addExchangeRate("EUR", "BYN", 3.62 + Math.random() * 0.02, LocalDateTime.now());
        addExchangeRate("EUR", "USD", 1.18 + Math.random() * 0.02, LocalDateTime.now());
    }

    private void addExchangeRate(String fromCurrency, String toCurrency, double rate, LocalDateTime timestamp) {
        Pair<String, String> currencyPair = Pair.of(fromCurrency, toCurrency);
        exchangeRates
            .computeIfAbsent(currencyPair, k -> new TreeMap<>())
            .put(timestamp, rate);
    }

    public double getExchangeRate(String fromCurrency, String toCurrency, LocalDateTime timestamp) {
        Pair<String, String> currencyPair = Pair.of(fromCurrency, toCurrency);
        TreeMap<LocalDateTime, Double> rates = exchangeRates.get(currencyPair);

        if (rates == null || rates.isEmpty()) {
            throw new IllegalArgumentException("No exchange rates available for this currency pair.");
        }

        // Найти курс, актуальный для заданной временной метки
        Map.Entry<LocalDateTime, Double> entry = rates.floorEntry(timestamp);

        if (entry == null) {
            throw new IllegalStateException("No valid exchange rate found for the given time.");
        }

        return entry.getValue();
    }

    public double convert(String fromCurrency, String toCurrency, double amount, LocalDateTime timestamp) {
        double rate = getExchangeRate(fromCurrency, toCurrency, timestamp);
        return amount * rate;
    }

    private void startPeriodicRateUpdate() {
        scheduler.scheduleAtFixedRate(
            this::addExchangeRate,
            0,
            2,
            TimeUnit.SECONDS
        );
    }

    public void stopService() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            scheduler.shutdownNow();
        }
    }

    public static void case1() throws InterruptedException {
        CurrencyExchanger exchanger = new CurrencyExchanger();
        exchanger.addExchangeRate("USD", "BYN", 3.45, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("USD", "BYN", 3.47, LocalDateTime.of(2025, 1, 25, 17, 30));
        exchanger.addExchangeRate("USD", "BYN", 3.41, LocalDateTime.of(2025, 1, 26, 10, 15));
        exchanger.addExchangeRate("BYN", "USD", 0.29, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("EUR", "BYN", 3.62, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("BYN", "EUR", 0.27, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("USD", "EUR", 0.85, LocalDateTime.of(2025, 1, 25, 13, 0));
        exchanger.addExchangeRate("EUR", "USD", 1.18, LocalDateTime.of(2025, 1, 25, 13, 0));

        Thread.sleep(10000);

        exchanger.stopService();

        double convertedAmount = exchanger.convert("USD", "BYN", 100, LocalDateTime.of(2025, 1, 25, 18, 0));
        System.out.println(convertedAmount);
    }

}
```
## LeetCode 127. Word Ladder

### Graph – BFS – Shortest Path

Problem Summary:
Given two words (beginWord and endWord), and a dictionary (wordList), return the length of the shortest transformation sequence from beginWord to endWord. Each transformation must change exactly one letter and the resulting word must be in the wordList.

```java
/**
 * Solves the Word Ladder problem using BFS to find the shortest transformation sequence.
 * Time complexity: O(N * M^2), where N is the number of words and M is the length of each word.
 */
public class WordLadder {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>(wordList);
        if (!wordSet.contains(endWord)) return 0;

        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        int level = 1;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String current = queue.poll();
                for (int j = 0; j < current.length(); j++) {
                    char[] chars = current.toCharArray();
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (chars[j] == c) continue;
                        chars[j] = c;
                        String next = new String(chars);
                        if (next.equals(endWord)) return level + 1;
                        if (wordSet.contains(next) && !visited.contains(next)) {
                            visited.add(next);
                            queue.offer(next);
                        }
                    }
                }
            }
            level++;
        }
        return 0;
    }
}
```

Concepts Covered:

Graph modeling of word transformations
Breadth-first search (BFS) to find shortest path
Dynamic neighbor generation (not stored in advance)



